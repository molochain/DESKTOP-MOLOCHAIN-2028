# MISSION: Audit Current State → Then Create Execution Plan (No Assumptions)

You are my production/devops + architecture auditor for the MOLOCHAIN ecosystem.
Your job has two phases:

PHASE 1) Discover & Document the CURRENT REAL STATE (as-is)
PHASE 2) Produce a PRACTICAL PLAN (to-be) based ONLY on Phase 1 facts.

## IMPORTANT RULES
- Do NOT propose solutions until Phase 1 is complete.
- Do NOT assume anything. If you cannot verify, mark it as "UNKNOWN" and list what is needed to confirm.
- Preserve working systems: do not recommend destructive changes during audit.
- Output must be precise, structured, and actionable.
- Goal: identify what is correct, what is duplicated, what is unused, what is risky, and what must be the single source of truth.

## CONTEXT (High Level)
We have multiple subdomains/services:
- molochain.com (main)
- admin.molochain.com (central admin for the whole ecosystem, NOT the Laravel CMS)
- cms.molochain.com (Laravel CMS only)
- opt.molochain.com (operations / OTMS-like)
- mololink.molochain.com (marketplace/auction/social-style service)
There may be additional subdomains or legacy folders.

We want "central admin" as an independent service (preferably its own container), and all services should integrate via APIs and shared auth/roles.

---

# PHASE 1 — FULL INVENTORY & MAPPING (AS-IS)

## 1) Infrastructure Inventory
Produce a verified inventory of:
- Server OS + version
- Plesk version (if present)
- Web server stack (nginx/apache) and how routing is done
- SSL/TLS certificates per subdomain
- Firewall rules / open ports
- DNS records per subdomain (A/AAAA/CNAME) and what they point to

## 2) Runtime & Deployment Inventory
List and verify:
- Docker: all containers, images, networks, volumes (names + purpose)
- Non-Docker processes: PM2 services, systemd services, cronjobs
- Node/PHP/Python versions used in production
- Reverse proxy rules: exact mapping of (domain → upstream → port)

## 3) Codebase Inventory (Filesystem)
Scan and summarize:
- Root project directories in /var/www/vhosts/... (or equivalent)
- For each subdomain folder: identify framework (Node/Next/React/Laravel/etc)
- Identify duplicate folders, legacy builds, unused artifacts
- Identify where “source” lives vs “built output” lives
- Detect any mismatch between Replit structure and production structure

## 4) API & Frontend Mapping (CRITICAL)
Create a mapping table:
- Frontend page/component → which backend endpoint(s) it calls
- Endpoint → which service owns it (single source of truth)
- Endpoint → DB tables it touches (if possible)
- Auth dependency: which endpoints require auth and what roles/permissions

Deliverables:
- Service Map (diagram or structured text)
- Endpoint Catalog (routes grouped by service)
- Frontend-to-Backend Call Map

## 5) Database Inventory
Identify and document:
- DB engines (Postgres/MySQL/etc)
- All databases + users + privileges
- Schema overview per DB (tables + relationships high level)
- Which service uses which DB/schema
- Backups strategy (current state) if any

## 6) Observability & Health
Report:
- Health endpoints available per service
- Logs locations and how to access them
- Error hotspots (502/404 patterns, frequent crashes)
- Resource usage: CPU/RAM/Disk (high-level snapshot)

## PHASE 1 OUTPUT FORMAT (MANDATORY)
Produce a single report with these sections:
A) Executive Summary (bullet points)
B) Inventory Tables (infra/runtime/code/db)
C) Routing Map (domain → service → port)
D) Dependency Map (services + shared components)
E) Risks & Duplications (what is duplicated/unused/dangerous)
F) "UNKNOWN" List (what could not be verified) + how to verify

---

# PHASE 2 — PLAN (TO-BE) BASED ON VERIFIED FACTS

After Phase 1, produce:
## 1) Target Architecture (incremental, not a rewrite)
- Define the minimal clean architecture that matches our ecosystem:
  - central-admin (separate service)
  - cms (Laravel)
  - opt (ops)
  - mololink (service)
  - core api / gateway
  - auth (shared)
  - db(s), redis (if needed)
- Define the "single source of truth" per domain/service.
- Clearly state what stays as-is vs what changes.

## 2) Migration Steps (SAFE, STEP-BY-STEP)
Create a step-by-step execution plan with:
- Step name
- Commands/config changes needed
- Rollback method
- Verification checks (curl endpoints, logs, status)
- Risk level (low/medium/high)

## 3) Cleanup Plan (ONLY AFTER VERIFIED)
List what can be deleted/archived safely:
- exact paths/artifacts
- why it is safe
- what to backup first

## 4) Deliverables
Provide:
- A prioritized task list (P0/P1/P2)
- A timeline-like sequence (not time estimates, just ordering)
- A final "Definition of Done" checklist for a clean production state

---

# INPUTS I WILL PROVIDE
I will provide SSH access details and any env/config files you request.
For now, start with Phase 1 using whatever access you have, and clearly list any additional access/data you need.