Analyze the entire codebase and generate a precise mapping of how the frontend, backend, and database interact.
Your main goal:
For every user-facing page / component in the frontend, show exactly which backend endpoint(s) it uses and which database tables are involved behind the scenes.
________________________________________
1) Scope of the analysis
Scan at least these areas (adjust paths if needed based on the project):
Frontend:
•	client/src/pages/**
•	client/src/components/**
•	client/src/routes/**
•	client/src/hooks/**
•	client/src/api/** (or any similar API/queries folder)
Backend:
•	server/routes/**
•	server/controllers/** (if present)
•	server/services/**
•	server/storage/** or server/repositories/**
Shared / Types / Schemas:
•	shared/**
Database:
•	db/schema.ts
•	shared/schema.ts
•	any Drizzle model / migration folders like db/migrations/**
If some of these paths do not exist, auto-detect the equivalents by looking for React components, Express routes, services, Drizzle schemas, etc.
________________________________________
2) Output: mapping structure
Build a clear mapping for each connection between frontend and backend, including database.
For each frontend route or page, produce an object with:
•	frontendRoute: the URL path (e.g. /dashboard, /services/tracking)
•	pageComponent: React component file and name, e.g.:
o	file: client/src/pages/DashboardPage.tsx
o	name: DashboardPage
•	usedHooksOrQueries: list of hooks / query functions used in that page, e.g.:
o	["useTrackingData", "useUserProfile"]
•	apiClientCalls: list of API client functions called, e.g.:
o	["trackingApi.getShipments", "authApi.getMe"]
•	httpRequests: resolved HTTP calls (method + URL), e.g.:
o	[{ "method": "GET", "url": "/api/tracking" }, { "method": "GET", "url": "/api/me" }]
•	backendHandler: resolved backend implementation, including:
o	routeFile: e.g. server/routes/tracking.ts
o	handlerFunction: e.g. getTrackingListHandler
o	serviceFile: e.g. server/services/tracking/service.ts
o	serviceMethod: e.g. getTrackingList
•	storageLayer: if used:
o	storageFile: e.g. server/storage/trackingStorage.ts
o	storageMethod: e.g. findByUserId
o	storageInterface: e.g. IStorage
•	databaseAccess: Drizzle / DB level:
o	table: e.g. "trackingEvents"
o	schemaFile: e.g. "db/schema.ts" or "shared/schema.ts"
•	notes: any useful notes such as:
o	"deprecated", "unused", "multiple endpoints", "read-only", etc.
Output this mapping in two formats:
1.	A Markdown table summarizing the main fields for human reading.
2.	A JSON array containing the full detailed mapping, for example:
________________________________________
3) Extra analysis
In addition to the mapping above, also:
1.	List frontend components/pages that do NOT call any backend endpoint:
o	Provide their file path and route (if applicable).
2.	List backend endpoints that are never used by the frontend:
o	For each: HTTP method, URL, route file, handler function.
3.	List database tables that are defined but never accessed via services/storage:
o	For each: table name, schema file, and where it is defined.
________________________________________
4) Suggested database structure for storing the mapping
Propose a table or schema that could be used to store this mapping in the database in the future.
You do not need to create or migrate it, just define it.
If the project uses Drizzle, also provide an equivalent Drizzle schema definition.
________________________________________
5) Output format
•	Provide the Markdown table first for human inspection.
•	Provide the full JSON mapping inside a fenced code block after that.
•	Use exact and accurate file paths and names.
•	This task must be read-only: do not modify or delete any code or database objects.
